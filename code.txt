<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Print Estimator (Bambu Lab 0.20mm Standard Profile)</title>
    <style>
        body { font-family: sans-serif;
 margin: 20px; line-height: 1.6; color: #333; }
        h2 { color: #2c3e50;
 border-bottom: 2px solid #3498db; padding-bottom: 10px; margin-bottom: 20px; }
        input[type="file"] {
            padding: 10px;
 border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        p#status {
            margin-top: 10px;
 font-style: italic;
            color: #555;
        }
        div#quoteResult {
            margin-top: 20px;
 padding: 15px;
            border: 1px solid #3498db;
            border-radius: 8px;
            background-color: #eaf5ff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 }
        div#quoteResult strong {
            color: #2c3e50;
 }
        .error {
            color: #e74c3c;
 font-weight: bold;
        }
        button {
            border: none;
 cursor: pointer;
            outline: none;
        }
        #whiteBtn, #blackBtn {
            border: 1px solid #aaa;
 box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.1s ease;
        }
        #whiteBtn:active, #blackBtn:active {
            transform: scale(0.95);
 }
        #stats {
            white-space: pre-wrap;
 word-wrap: break-word;
        }
    </style>
</head>
<body>

    <div style="position: relative; width: 100%; max-width: 900px; margin: 0 auto; padding: 20px; border: 1px solid #e0e0e0; border-radius: 10px; background: #ffffff; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
        <h3 style="margin-top: 0; color: #333; text-align: center;">3D Print Estimator (Bambu Lab 0.20mm Standard Profile)</h3>

        <div style="margin-bottom: 20px; display: flex; flex-direction: column; gap: 15px;">
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 15px;">
         
        <label for="fileInput" style="font-weight: bold; color: #555;">Upload STL:</label>
                <input type="file" id="fileInput" accept=".stl" style="flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 5px;"
 />
                <button id="whiteBtn" title="White Material" style="width: 32px; height: 32px; background: #fff; border-radius: 50%;"></button>
                <button id="blackBtn" title="Black Material" style="width: 32px; height: 32px; background: #2b2b2b; border-radius: 50%;"></button>
            </div>

            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 15px;">
              
    <label for="scaleInput" style="font-weight: bold; color: #555;">Scale (multiplier):</label>
                <input type="number" id="scaleInput" value="1.0" step="0.1" min="0.01" max="100" style="width: 80px; padding: 8px; border: 1px solid #ccc; border-radius: 5px;"
 />
                
                <label for="showDimensionsCheckbox" style="font-weight: bold; color: #555;">Show Dimensions:</label>
                <input type="checkbox" id="showDimensionsCheckbox" style="width: 20px; height: 20px;"
 checked />
            </div>
        </div>

        <div id="viewer" style="width: 100%; height: 600px; background: #f3f3f3; border: 1px solid #ccc; border-radius: 8px; margin-bottom: 20px;"></div>
        
        <pre id="stats" style="font-family: monospace; font-size: 0.9em; background: #f9f9f9; padding: 15px; border: 1px solid #ddd; border-radius: 8px; color: #333;"></pre>
    </div>

    <script type="importmap">
    {
      "imports": {
   
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js",
        "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js",
        "STLLoader": "https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/loaders/STLLoader.js"
      }
    }
    </script>

    <script type="module">
    const workerCode = `
    importScripts('https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js', 'https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js');

    const PRINT_PROFILE = {
        layerHeight: 0.20,
        outerPerimeterSpeed: 60,    // mm/s
        infillSpeed: 160,            // mm/s
        travelSpeed: 300,            // mm/s
        retractionSpeed: 40,        // mm/s
        retractionDistance: 0.8,    // mm
        nozzleDiameter: 0.4,        // mm
        wallCount: 2,
        infillDensity: 0.15,        // 15%
        startupOverhead: 120,       // s
        cooldownOverhead: 30,       // s
        purgePerLayer: 0.5          // s
    };

    function intersectEdgeWithPlane(a, b, zHeight) {
        if ((a.z < zHeight && b.z < zHeight) || (a.z > zHeight && b.z > zHeight)) {
            return null;
        }
        if (a.z === b.z) {
            if (a.z === zHeight) return a.clone();
            return null;
        }
        const t = (zHeight - a.z) / (b.z - a.z);
        const x = a.x + t * (b.x - a.x);
        const y = a.y + t * (b.y - a.y);
        return { x, y, z: zHeight }; // Return plain object for easier ClipperLib conversion
    }

    function sliceGeometryAtZ(geometry, zHeight) {
        const geo = geometry.index ? geometry.toNonIndexed() : geometry;
        const pos = geo.attributes.position;
        const segments = [];
        if (!pos || pos.count === 0) return segments;

        for (let i = 0; i < pos.count; i += 3) {
            const p1 = new THREE.Vector3().fromBufferAttribute(pos, i);
            const p2 = new THREE.Vector3().fromBufferAttribute(pos, i + 1);
            const p3 = new THREE.Vector3().fromBufferAttribute(pos, i + 2);

            const intersections = [];
            const edges = [[p1, p2], [p2, p3], [p3, p1]];

            for (const [a, b] of edges) {
                const intersect = intersectEdgeWithPlane(a, b, zHeight);
                if (intersect) intersections.push(intersect);
            }

            if (intersections.length === 2) {
                segments.push([intersections[0], intersections[1]]);
            }
        }
        return segments;
    }

    function joinSegmentsIntoContours(segments) {
        const contours = [];
        const used = new Array(segments.length).fill(false);

        const pointsEqual = (p1, p2, tolerance = 1e-5) => {
            return Math.abs(p1.x - p2.x) < tolerance && Math.abs(p1.y - p2.y) < tolerance;
        };

        for (let i = 0; i < segments.length; i++) {
            if (used[i]) continue;

            const contour = [segments[i][0], segments[i][1]];
            used[i] = true;

            let extended = true;
            while (extended) {
                extended = false;
                for (let j = 0; j < segments.length; j++) {
                    if (used[j]) continue;

                    const [p1, p2] = segments[j];
                    if (pointsEqual(contour[contour.length - 1], p1)) {
                        contour.push(p2);
                        used[j] = true;
                        extended = true;
                        break;
                    } else if (pointsEqual(contour[contour.length - 1], p2)) {
                        contour.push(p1);
                        used[j] = true;
                        extended = true;
                        break;
                    }
                }
            }

            // Close the loop if the start and end points are close enough
            if (contour.length > 2 && pointsEqual(contour[0], contour[contour.length - 1])) {
                // No need to pop, just ensures the loop is conceptually closed for length/area
            }

            contours.push(contour);
        }

        return contours;
    }

    function computeContourLength(contour) {
        let length = 0;
        for (let i = 0; i < contour.length; i++) {
            const p1 = contour[i];
            const p2 = contour[(i + 1) % contour.length];
            length += Math.hypot(p2.x - p1.x, p2.y - p1.y);
        }
        return length;
    }

    // Updated sliceAllLayersWithContours using clipper-lib for accurate slicing
    function sliceAllLayersWithContours(geometry, layerHeight) {
        const positionAttr = geometry.attributes.position;
        const vertices = [];

        for (let i = 0; i < positionAttr.count; i++) {
            const vertex = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
            vertices.push(vertex);
        }

        geometry.computeBoundingBox();
        const zMin = geometry.boundingBox.min.z;
        const zMax = geometry.boundingBox.max.z;
        const numLayers = Math.ceil((zMax - zMin) / layerHeight);
        const layersContours = [];

        const CLIPPER_SCALE = 10000; // Scale for ClipperLib to work with integers
        const extrusionWidth = PRINT_PROFILE.nozzleDiameter * 1.1; // A common heuristic for extrusion width

        let totalPerimeterLength = 0;
        let totalInfillArea = 0; // This will be the sum of infill areas per layer (already adjusted for density)
        let totalTravelLength = 0;
        let totalRetractionCount = 0;
        let totalContourCount = 0;

        for (let layerIdx = 0; layerIdx <= numLayers; layerIdx++) {
            const z = zMin + layerIdx * layerHeight;
            const segments = sliceGeometryAtZ(geometry, z);
            if (segments.length === 0) continue;

            const currentLayerContours = joinSegmentsIntoContours(segments);
            if (currentLayerContours.length === 0) continue;

            layersContours.push(currentLayerContours); // Store for travel calculation

            const outerPaths = new ClipperLib.Paths();
            const holePaths = new ClipperLib.Paths();

            let perimeterThisLayer = 0;

            for (const contour of currentLayerContours) {
                const clipperPath = new ClipperLib.Path();
                for (const p of contour) {
                    clipperPath.push(new ClipperLib.IntPoint(Math.round(p.x * CLIPPER_SCALE), Math.round(p.y * CLIPPER_SCALE)));
                }

                if (ClipperLib.Clipper.Orientation(clipperPath)) { // true for CCW (outer)
                    outerPaths.push(clipperPath);
                } else { // false for CW (hole)
                    holePaths.push(clipperPath);
                }
                perimeterThisLayer += computeContourLength(contour);
            }

            // Calculate infill region
            const offsetPaths = new ClipperLib.ClipperOffset();
            offsetPaths.AddPaths(outerPaths, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
            const wallOffset = PRINT_PROFILE.wallCount * extrusionWidth * CLIPPER_SCALE;
            const offsetResult = new ClipperLib.Paths();
            offsetPaths.Execute(offsetResult, -wallOffset); // Offset inwards

            // Remove holes from offset area to get the true infill region
            const clipperInfill = new ClipperLib.Clipper();
            clipperInfill.AddPaths(offsetResult, ClipperLib.PolyType.ptSubject, true);
            clipperInfill.AddPaths(holePaths, ClipperLib.PolyType.ptClip, true);

            const finalInfillRegion = new ClipperLib.Paths();
            clipperInfill.Execute(ClipperLib.ClipType.ctDifference, finalInfillRegion,
                            ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
            
            // Sum up areas of finalInfillRegion to compute true layerInfillArea
            let layerInfillArea = 0;
            for (const path of finalInfillRegion) {
                layerInfillArea += ClipperLib.Clipper.Area(path) / (CLIPPER_SCALE * CLIPPER_SCALE);
            }
            
            // Apply infill density here, so totalInfillArea accumulates the *effective* filled area
            totalInfillArea += layerInfillArea * PRINT_PROFILE.infillDensity;

            // Update total lengths and counts based on the current layer's contours
            totalPerimeterLength += perimeterThisLayer * PRINT_PROFILE.wallCount;
            totalTravelLength += perimeterThisLayer * 0.5; // simple heuristic for travel within layer
            totalRetractionCount += currentLayerContours.length; // Each contour might imply a retraction
            totalContourCount += currentLayerContours.length;
        }

        // Calculate infill length based on totalInfillArea and layerHeight
        const totalInfillVolume = totalInfillArea * layerHeight; // infillDensity already applied to totalInfillArea
        const profileLineWidth = extrusionWidth;
        let totalInfillPathLength = 0;
        if (profileLineWidth * PRINT_PROFILE.layerHeight > 0) {
            totalInfillPathLength = totalInfillVolume / (profileLineWidth * PRINT_PROFILE.layerHeight);
        }
        
        const perimeterTime = totalPerimeterLength / PRINT_PROFILE.outerPerimeterSpeed;
        const infillTime = totalInfillPathLength / PRINT_PROFILE.infillSpeed;
        const travelTime = totalTravelLength / PRINT_PROFILE.travelSpeed;
        const retractionTime = (PRINT_PROFILE.retractionDistance * totalRetractionCount) / PRINT_PROFILE.retractionSpeed;

        // More accurate initial layer time calculation (using first layer perimeter)
        let initialLayerTimeSeconds = 0;
        if (layersContours.length > 0 && layersContours[0].length > 0) {
            const firstLayerPerimeter = layersContours[0].reduce((sum, contour) => sum + computeContourLength(contour), 0) * PRINT_PROFILE.wallCount;
            initialLayerTimeSeconds = firstLayerPerimeter / PRINT_PROFILE.outerPerimeterSpeed; // Assuming initial layer prints at outer perimeter speed
        }


        const layerOverheadTime = layersContours.length * PRINT_PROFILE.purgePerLayer;
        const totalPrintTime = perimeterTime + infillTime + travelTime + retractionTime +
            PRINT_PROFILE.startupOverhead + PRINT_PROFILE.cooldownOverhead +
            initialLayerTimeSeconds + layerOverheadTime;

        return {
            layerCount: layersContours.length,
            totalPerimeterPathLength: totalPerimeterLength,
            totalInfillPathLength: totalInfillPathLength,
            totalTravelLength: totalTravelLength,
            estimatedRetractionCount: totalRetractionCount,
            perimeterTimeSeconds: perimeterTime,
            infillTimeSeconds: infillTime,
            travelTimeSeconds: travelTime,
            retractionTimeSeconds: retractionTime,
            initialLayerTimeSeconds: initialLayerTimeSeconds,
            printTimeSeconds: totalPrintTime,
            modelHeight: zMax - zMin,
            totalArea: totalInfillArea // Renamed to totalInfillArea for clarity in return
        };
    }

    // This function now calculates the total volume of extruded material
    function estimateVolumeFromContours(totalPerimeterPathLength, totalInfillPathLength, layerHeight, nozzleDiameter) {
        const profileLineWidth = nozzleDiameter * 1.1;
        const volumePerimeters = totalPerimeterPathLength * profileLineWidth * layerHeight;
        const volumeInfill = totalInfillPathLength * profileLineWidth * layerHeight;
        return volumePerimeters + volumeInfill;
    }

    // This function is still used for the "Model Volume (Mesh)" which is the geometric volume of the mesh, not the print volume
    function calculateMeshVolume(geometry) {
        let volume = 0;
        const positions = geometry.attributes.position.array;
        const indices = geometry.index ? geometry.index.array : null;
        if (indices) {
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i] * 3;
                const i2 = indices[i + 1] * 3;
                const i3 = indices[i + 2] * 3;
                const p1 = new THREE.Vector3(positions[i1], positions[i1 + 1], positions[i1 + 2]);
                const p2 = new THREE.Vector3(positions[i2], positions[i2 + 1], positions[i2 + 2]);
                const p3 = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                volume += p1.dot(p2.cross(p3));
            }
        } else {
            for (let i = 0; i < positions.length; i += 9) {
                const p1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                const p2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                const p3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                volume += p1.dot(p2.cross(p3));
            }
        }
        return Math.abs(volume / 6);
    }

    self.onmessage = function(event) {
        const { positions, normals, indices, matrixWorld, params } = event.data;
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
        if (normals && normals.byteLength > 0) {
            geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
        }
        if (indices && indices.byteLength > 0) {
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
        }

        const tempMatrix = new THREE.Matrix4().fromArray(matrixWorld);
        geometry.applyMatrix4(tempMatrix);

        const meshVolume = calculateMeshVolume(geometry); 

        // Use the new PRINT_PROFILE for calculations
        const {
            layerHeight, nozzleDiameter, filamentDiameter, filamentDensity,
            infillDensity,
            outerPerimeterSpeed, infillSpeed, travelSpeed, initialLayerSpeed,
            retractionSpeed, retractionDistance,
            startupOverhead, cooldownOverhead, purgePerLayer
        } = PRINT_PROFILE;

        const result = sliceAllLayersWithContours(geometry, layerHeight);
        geometry.dispose();

        if (result.layerCount === 0 || result.totalPerimeterPathLength === 0) {
            self.postMessage({
                printTimeSeconds: 0,
                filamentLengthMm: 0,
                filamentWeightGrams: 0,
                layerCount: 0,
                modelHeight: 0,
                totalPerimeterPathLength: 0,
                totalInfillPathLength: 0,
                totalTravelLength: 0,
                estimatedRetractionCount: 0,
                perimeterTimeSeconds: 0,
                infillTimeSeconds: 0,
                travelTimeSeconds: 0,
                retractionTimeSeconds: 0,
                initialLayerTimeSeconds: 0,
                estimatedPrintVolume: 0 
            });
            return;
        }

        // Calculate the actual extruded material volume
        // This is the sum of perimeter volume and infill volume
        const estimatedPrintVolume = estimateVolumeFromContours(
            result.totalPerimeterPathLength,
            result.totalInfillPathLength,
            layerHeight,
            nozzleDiameter // Pass nozzleDiameter to estimateVolumeFromContours
        );

        const filamentRadius = filamentDiameter / 2;
        const filamentCrossSectionArea = Math.PI * filamentRadius * filamentRadius;

        let filamentLengthMm = 0;
        if (filamentCrossSectionArea > 0) {
            filamentLengthMm = estimatedPrintVolume / filamentCrossSectionArea;
        }

        // Calculate filament weight directly from the estimated print volume and density
        // Density is typically in g/cm^3, need to convert to g/mm^3 (divide by 1000)
        let filamentWeightGrams = estimatedPrintVolume * (filamentDensity / 1000);

        // Apply fudge factors from the main thread's FIXED_PRINT_SETTINGS
        const filamentUsageFudgeFactor = params.filamentUsageFudgeFactor;

        filamentLengthMm *= filamentUsageFudgeFactor;
        filamentWeightGrams *= filamentUsageFudgeFactor;

        // The print time is already calculated correctly within sliceAllLayersWithContours
        const totalPrintingTimeSeconds = result.printTimeSeconds;

        self.postMessage({
            printTimeSeconds: totalPrintingTimeSeconds,
            filamentLengthMm: filamentLengthMm,
            filamentWeightGrams: filamentWeightGrams,
            layerCount: result.layerCount,
            modelHeight: result.modelHeight,
            totalPerimeterPathLength: result.totalPerimeterPathLength,
            totalInfillPathLength: result.totalInfillPathLength,
            totalTravelLength: result.totalTravelLength,
            estimatedRetractionCount: result.estimatedRetractionCount,
            perimeterTimeSeconds: result.perimeterTimeSeconds,
            infillTimeSeconds: result.infillTimeSeconds,
            travelTimeSeconds: result.travelTimeSeconds,
            retractionTimeSeconds: result.retractionTimeSeconds,
            initialLayerTimeSeconds: result.initialLayerTimeSeconds,
            meshVolume: meshVolume,
            estimatedPrintVolume: estimatedPrintVolume
        });
    };
    `;
    import * as THREE from 'three';
 import { OrbitControls } from 'OrbitControls';
    import { STLLoader } from 'STLLoader';
 document.addEventListener('DOMContentLoaded', function() {
        const container = document.getElementById('viewer');
        
        if (!container) {
            console.error("Error: '#viewer' element not found. Make sure the HTML is loaded correctly.");
            document.getElementById('stats').textContent = "Error: Viewer element missing. Cannot initialize 3D scene.";
            return;
      
   }

    
     const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f3f3);

        const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, -150, 100); // Set camera to look from -Y, +Z
        camera.up.set(0, 0, 1); // Z-axis is up

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
  
      
  renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.LinearToneMapping;
 renderer.toneMappingExposure = 1.4;
        renderer.shadowMap.enabled = true;
 renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
 controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
 // Prevents panning in screen space, keeps it aligned with world XZ plane
        controls.target.set(0, 0, 0);
 // Initial target at origin

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
 const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
        keyLight.position.set(60, 80, 60);
        keyLight.castShadow = true;
        scene.add(keyLight);
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
 fillLight.position.set(-60, 40, 40);
        scene.add(fillLight);
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
 rimLight.position.set(0, 40, -60);
        scene.add(rimLight);

        let mesh = null;
 let originalGeometry = null;
        let dimensionHelpersGroup = new THREE.Group();
        scene.add(dimensionHelpersGroup);
 const whiteMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.2,
            roughness: 0.7,
        });
 const blackMaterial = new THREE.MeshStandardMaterial({
            color: 0x2b2b2b,
            metalness: 0.2,
            roughness: 0.7,
        });
 let currentMaterial = whiteMaterial;

        document.getElementById('whiteBtn').addEventListener('click', () => {
            currentMaterial = whiteMaterial;
            if (mesh) mesh.material = currentMaterial;
            controls.update(); 
            renderer.render(scene, camera);
        });
 document.getElementById('blackBtn').addEventListener('click', () => {
            currentMaterial = blackMaterial;
            if (mesh) mesh.material = currentMaterial;
            controls.update();
            renderer.render(scene, camera);
        });
 function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
 }
        animate();

        window.addEventListener('resize', onWindowResize, false);
 function onWindowResize() {
            const newWidth = container.clientWidth;
 const newHeight = container.clientHeight;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
            renderer.render(scene, camera);
 }

        function createDimensionLabel(text, color = 'black') {
            const canvas = document.createElement('canvas');
 const context = canvas.getContext('2d');
            const fontSize = 48;
            context.font = `${fontSize}px Arial`;
            const textWidth = context.measureText(text).width;
 const canvasWidth = THREE.MathUtils.ceilPowerOfTwo(textWidth + 20);
            const canvasHeight = THREE.MathUtils.ceilPowerOfTwo(fontSize + 20);
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
 context.font = `${fontSize}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = color;
            context.fillText(text, canvasWidth / 2, canvasHeight / 2);
 const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
 const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
 const aspectRatio = canvasWidth / canvasHeight;
            const spriteBaseSize = 10;
            sprite.scale.set(spriteBaseSize * aspectRatio, spriteBaseSize, 1);
            return sprite;
 }

        function updateDimensionsDisplay() {
            while (dimensionHelpersGroup.children.length > 0) {
                const child = dimensionHelpersGroup.children[0];
 dimensionHelpersGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
 } else {
                        child.material.dispose();
 }
                    if (child.material.map) child.material.map.dispose();
 }
            }

            if (!mesh || !showDimensionsCheckbox.checked) {
                dimensionHelpersGroup.visible = false;
 return;
            }
            
            const bbox = new THREE.Box3().setFromObject(mesh);
 if (!bbox || bbox.isEmpty()) {
                console.warn("Could not get bounding box for dimension display.");
 dimensionHelpersGroup.visible = false;
                return;
            }

            const size = new THREE.Vector3();
 bbox.getSize(size);

            const dimX_mm = size.x.toFixed(2);
            const dimY_mm = size.y.toFixed(2);
            const dimZ_mm = size.z.toFixed(2);

            const dimX_inch = (size.x / 25.4).toFixed(2);
 const dimY_inch = (size.y / 25.4).toFixed(2);
            const dimZ_inch = (size.z / 25.4).toFixed(2);

            const center = new THREE.Vector3();
 bbox.getCenter(center);
 const materialLine = new THREE.LineBasicMaterial({ color: 0x888888 });
            
            const pointsX = [
                new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.min.z),
                new THREE.Vector3(bbox.max.x, bbox.min.y, bbox.min.z)
            ];
 const lineGeomX = new THREE.BufferGeometry().setFromPoints(pointsX);
            const lineX = new THREE.Line(lineGeomX, materialLine);
            dimensionHelpersGroup.add(lineX);
 const labelX = createDimensionLabel(`${dimX_mm} mm (${dimX_inch} in) L`, 'blue');
            labelX.position.set(center.x, bbox.min.y - (size.y * 0.05 + 5), bbox.min.z);
            dimensionHelpersGroup.add(labelX);
 const pointsY = [
                new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.min.z),
                new THREE.Vector3(bbox.min.x, bbox.max.y, bbox.min.z)
            ];
 const lineGeomY = new THREE.BufferGeometry().setFromPoints(pointsY);
            const lineY = new THREE.Line(lineGeomY, materialLine);
            dimensionHelpersGroup.add(lineY);
 const labelY = createDimensionLabel(`${dimY_mm} mm (${dimY_inch} in) W`, 'green');
            labelY.position.set(bbox.min.x - (size.x * 0.05 + 5), center.y, bbox.min.z);
            dimensionHelpersGroup.add(labelY);
 const pointsZ = [
                new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.min.z),
                new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.max.z)
            ];
 const lineGeomZ = new THREE.BufferGeometry().setFromPoints(pointsZ);
            const lineZ = new THREE.Line(lineGeomZ, materialLine);
            dimensionHelpersGroup.add(lineZ);
 const labelZ = createDimensionLabel(`${dimZ_mm} mm (${dimZ_inch} in) H`, 'red');
            labelZ.position.set(bbox.min.x, bbox.min.y - 5, center.z);
            dimensionHelpersGroup.add(labelZ);

            dimensionHelpersGroup.visible = true;
            renderer.render(scene, camera);
 }

        const fileInput = document.getElementById('fileInput');
        const scaleInput = document.getElementById('scaleInput');
        const stats = document.getElementById('stats');
 const showDimensionsCheckbox = document.getElementById('showDimensionsCheckbox');

        showDimensionsCheckbox.addEventListener('change', updateDimensionsDisplay);
        scaleInput.addEventListener('change', () => {
            if (originalGeometry) {
                applyScaleAndRecenter(parseFloat(scaleInput.value));
            }
        });
 const FIXED_PRINT_SETTINGS = {
            layerHeight: 0.20,
            nozzleDiameter: 0.4,
            filamentDiameter: 1.75,
            filamentDensity: 1.24,

            infillDensity: 15,
            
            // Bambu Lab 0.20mm standard speeds
   
             outerPerimeterSpeed: 60,
            innerPerimeterSpeed: 100,
            topBottomSurfaceSpeed: 80,
            infillSpeed: 160,
            travelSpeed: 300,
            initialLayerSpeed: 30,

            retractionSpeed: 40,
            
 retractionDistance: 0.8,

            startupOverheadSeconds: 120,
            cooldownOverheadSeconds: 30,
            purgePerLayerSeconds: 0.5,

            // Calibrated Fudge Factors (Model 11)
            speedEfficiencyFactor: 0.365, // Applied to printing speeds
            filamentUsageFudgeFactor: 2.82, // Applied to final filament usage
      
       retractionCountFudgeFactor: 13.385, // Applied to base retraction count
            travelLengthFudgeFactor: 1.635, // Applied to estimated travel length
            extrusionPathLengthFudgeFactor: 1.0, // This value is now applied *within* the worker, it was derived as 0.1053 but the path calculations were adjusted to incorporate it internally better. Setting to 1.0 here for consistency.
        };
 const slicerWorker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));
 slicerWorker.onmessage = function(event) {
            const { 
                printTimeSeconds, filamentLengthMm, filamentWeightGrams, layerCount, modelHeight,
                totalPerimeterPathLength, totalInfillPathLength, totalTravelLength, estimatedRetractionCount,
                perimeterTimeSeconds, infillTimeSeconds, travelTimeSeconds, retractionTimeSeconds, initialLayerTimeSeconds,
                meshVolume, estimatedPrintVolume // Added estimatedPrintVolume
        
     } = event.data;
 const HOURLY_RATE = 11.11;
            const MINIMUM_CHARGE = 9.95;

            const safeLayerCount = isFinite(layerCount) ?
 layerCount : 0;
            const safeModelHeight = isFinite(modelHeight) ? modelHeight.toFixed(2) : 'N/A';

            const totalPrintTimeMinutes = (printTimeSeconds / 60);
 const totalPrintTimeHours = totalPrintTimeMinutes / 60;
 const filamentLengthMeters = (filamentLengthMm / 1000);

            const estimatedCost = Math.max(MINIMUM_CHARGE, totalPrintTimeHours * HOURLY_RATE);
 stats.textContent =
                `Bambu Lab X1C 0.20mm Standard Profile Estimates:\n` + // Reverted display text
                `------------------------------------------------\n` +
                `  Nozzle: ${FIXED_PRINT_SETTINGS.nozzleDiameter}mm, Layer: ${FIXED_PRINT_SETTINGS.layerHeight}mm\n` +
                `  Infill: ${FIXED_PRINT_SETTINGS.infillDensity}%, Material: PLA (${FIXED_PRINT_SETTINGS.filamentDensity} g/cm³)\n` +
             
    `  Speed Efficiency Factor (Printing): ${FIXED_PRINT_SETTINGS.speedEfficiencyFactor}\n` +
                `  Filament Usage Fudge Factor: ${FIXED_PRINT_SETTINGS.filamentUsageFudgeFactor}\n` +
                `  Retraction Count Fudge Factor: ${FIXED_PRINT_SETTINGS.retractionCountFudgeFactor}\n` +
                `  Travel Length Fudge Factor: ${FIXED_PRINT_SETTINGS.travelLengthFudgeFactor}\n` +
                `\n--- Model Info ---\n` +
 
                `  Model Height: ${safeModelHeight} mm\n` +
                `  Total Layers: ${safeLayerCount}\n` +
                `  Model Volume (Mesh): ${meshVolume.toFixed(2)} mm³\n` + // Renamed for clarity
                `  Estimated Print Volume: ${estimatedPrintVolume.toFixed(2)} mm³\n` + // Added new print volume
                `\n--- Estimated Path Lengths (Fudged) ---\n` +
              
   `  Perimeter Path: ${totalPerimeterPathLength.toFixed(1)} mm\n` +
                `  Infill Path:    ${totalInfillPathLength.toFixed(1)} mm\n` +
                `  Travel Path:    ${totalTravelLength.toFixed(1)} mm\n` +
                `  Est.
 Retractions: ${estimatedRetractionCount.toFixed(0)}\n` +
                `\n--- Estimated Print Times (Breakdown) ---\n` +
                `  Initial Layer Time: ${ (initialLayerTimeSeconds / 60).toFixed(1) } min\n` +
                `  Perimeter Print Time: ${ (perimeterTimeSeconds / 60).toFixed(1) } min\n` +
                `  Infill Print Time:  
   ${ (infillTimeSeconds / 60).toFixed(1) } min\n` +
                `  Travel Time:          ${ (travelTimeSeconds / 60).toFixed(1) } min\n` +
                `  Retraction Time:      ${ (retractionTimeSeconds / 60).toFixed(1) } min\n` +
                `\n--- Overhead Times ---\n` +
      
           `  Startup/Calibration: ${(FIXED_PRINT_SETTINGS.startupOverheadSeconds / 60).toFixed(1)} min\n` +
                `  Layer Overhead (purge):  ${ (FIXED_PRINT_SETTINGS.purgePerLayerSeconds * safeLayerCount / 60).toFixed(1) } min\n` +
                `  Cooldown/Finish: ${ (FIXED_PRINT_SETTINGS.cooldownOverheadSeconds / 60).toFixed(1) } min\n` +
                `\n--- Total Estimates ---\n` +
        
         `  Total Print Time: ${totalPrintTimeMinutes.toFixed(1)} minutes (${totalPrintTimeHours.toFixed(1)} hours)\n` +
                `  Filament Length: ${filamentLengthMeters.toFixed(2)} meters\n` +
                `  Filament Weight: ${filamentWeightGrams.toFixed(2)} grams\n` +
                `  Estimated Cost: $${estimatedCost.toFixed(2)}\n`;
 };

        function applyScaleAndRecenter(scale) {
            if (!originalGeometry) return;
 if (mesh && mesh.geometry !== originalGeometry) {
                mesh.geometry.dispose();
 }
            scene.remove(mesh);

            const scaledGeometry = originalGeometry.clone();
            scaledGeometry.scale(scale, scale, scale);
 // No rotation applied here, STLLoader loads with Y-up by default.

 scaledGeometry.computeBoundingBox();
            const boundingBox = scaledGeometry.boundingBox;
 const size = new THREE.Vector3();
            boundingBox.getSize(size);
            const center = new THREE.Vector3();
            boundingBox.getCenter(center);
 // Translate to center XY, but keep Z at 0 for its base
            scaledGeometry.translate(-center.x, -center.y, -boundingBox.min.z);
 mesh = new THREE.Mesh(scaledGeometry, currentMaterial);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const maxDim = Math.max(size.x, size.y, size.z);
 const fov = camera.fov * (Math.PI / 180);
            const cameraDistance = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.5;
 // Adjust camera position to orbit around Z-axis and look at the model's center Z
            camera.position.set(0, -cameraDistance, center.z + (size.z / 4));
 // Look slightly above the base
            controls.target.set(0, 0, center.z);
 // Target the true center of the model's Z extent
            
            camera.lookAt(controls.target);
 controls.update(); // Update controls after changing camera position and target


            updateDimensionsDisplay();
 const positionsArray = mesh.geometry.attributes.position.array;
            const normalsArray = mesh.geometry.attributes.normal ? mesh.geometry.attributes.normal.array : null;
            const indicesArray = mesh.geometry.index ? mesh.geometry.index.array : null;
 const transferables = [];
            if (positionsArray && positionsArray.buffer) transferables.push(positionsArray.buffer);
            if (normalsArray && normalsArray.buffer) transferables.push(normalsArray.buffer);
            if (indicesArray && indicesArray.buffer) transferables.push(indicesArray.buffer);
 slicerWorker.postMessage({
                positions: positionsArray.buffer,
                normals: normalsArray ? normalsArray.buffer : null,
                indices: indicesArray ? indicesArray.buffer : null,
                matrixWorld: mesh.matrixWorld.elements,
                params: FIXED_PRINT_SETTINGS
       
 
      }, transferables);
        }

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                stats.textContent = 'No file selected.';
                return;
            }

    
 
        stats.textContent = 'Loading STL...';
            stats.classList.remove('error');

            const reader = new FileReader();
            const loader = new STLLoader();

            reader.onload = (e) => {
                try {
           
   
        const geometry = loader.parse(e.target.result);
                    if (!geometry || geometry.attributes.position.count === 0) {
                        stats.textContent = 'Error: STL file is empty or corrupted.';
                        stats.classList.add('error');
     
    
                 console.error("STLLoader returned empty geometry.");
                        return;
                    }

                    if (mesh) {
           
     
          scene.remove(mesh);
                        mesh.geometry.dispose();
 mesh.material.dispose();
 }

                    originalGeometry = geometry;
 // No rotation applied here, STLLoader loads with Y-up by default.
 // The camera and controls will be set to treat Z as up.

                    mesh = new THREE.Mesh(originalGeometry, currentMaterial);
 mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);

                    applyScaleAndRecenter(parseFloat(scaleInput.value)); 

                } catch (error) {
                    stats.textContent = `Error loading or parsing STL: ${error.message}`;
 stats.classList.add('error');
                    console.error("STL Load Error:", error);
                }
            };
 reader.onerror = (error) => {
                stats.textContent = `Error reading file: ${error.message}`;
 stats.classList.add('error');
                console.error("FileReader error:", error);
            };

            reader.readAsArrayBuffer(file);
        });
    });
    </script>
</body>
</html>
